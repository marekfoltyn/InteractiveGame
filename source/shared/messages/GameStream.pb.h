// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GameStream.proto

#ifndef PROTOBUF_GameStream_2eproto__INCLUDED
#define PROTOBUF_GameStream_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_GameStream_2eproto();
void protobuf_AssignDesc_GameStream_2eproto();
void protobuf_ShutdownFile_GameStream_2eproto();

class PBGameStream;
class PBVec2;
class PBBall;
class PBPlayer;

enum PBTeam {
  RED = 0,
  BLUE = 1
};
bool PBTeam_IsValid(int value);
const PBTeam PBTeam_MIN = RED;
const PBTeam PBTeam_MAX = BLUE;
const int PBTeam_ARRAYSIZE = PBTeam_MAX + 1;

const ::google::protobuf::EnumDescriptor* PBTeam_descriptor();
inline const ::std::string& PBTeam_Name(PBTeam value) {
  return ::google::protobuf::internal::NameOfEnum(
    PBTeam_descriptor(), value);
}
inline bool PBTeam_Parse(
    const ::std::string& name, PBTeam* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PBTeam>(
    PBTeam_descriptor(), name, value);
}
// ===================================================================

class PBGameStream : public ::google::protobuf::Message {
 public:
  PBGameStream();
  virtual ~PBGameStream();

  PBGameStream(const PBGameStream& from);

  inline PBGameStream& operator=(const PBGameStream& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PBGameStream& default_instance();

  void Swap(PBGameStream* other);

  // implements Message ----------------------------------------------

  PBGameStream* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PBGameStream& from);
  void MergeFrom(const PBGameStream& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool active = 1;
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 1;
  inline bool active() const;
  inline void set_active(bool value);

  // optional double pitchRatio = 2;
  inline bool has_pitchratio() const;
  inline void clear_pitchratio();
  static const int kPitchRatioFieldNumber = 2;
  inline double pitchratio() const;
  inline void set_pitchratio(double value);

  // optional .PBBall ball = 3;
  inline bool has_ball() const;
  inline void clear_ball();
  static const int kBallFieldNumber = 3;
  inline const ::PBBall& ball() const;
  inline ::PBBall* mutable_ball();
  inline ::PBBall* release_ball();
  inline void set_allocated_ball(::PBBall* ball);

  // repeated .PBPlayer player = 4;
  inline int player_size() const;
  inline void clear_player();
  static const int kPlayerFieldNumber = 4;
  inline const ::PBPlayer& player(int index) const;
  inline ::PBPlayer* mutable_player(int index);
  inline ::PBPlayer* add_player();
  inline const ::google::protobuf::RepeatedPtrField< ::PBPlayer >&
      player() const;
  inline ::google::protobuf::RepeatedPtrField< ::PBPlayer >*
      mutable_player();

  // @@protoc_insertion_point(class_scope:PBGameStream)
 private:
  inline void set_has_active();
  inline void clear_has_active();
  inline void set_has_pitchratio();
  inline void clear_has_pitchratio();
  inline void set_has_ball();
  inline void clear_has_ball();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double pitchratio_;
  ::PBBall* ball_;
  ::google::protobuf::RepeatedPtrField< ::PBPlayer > player_;
  bool active_;
  friend void  protobuf_AddDesc_GameStream_2eproto();
  friend void protobuf_AssignDesc_GameStream_2eproto();
  friend void protobuf_ShutdownFile_GameStream_2eproto();

  void InitAsDefaultInstance();
  static PBGameStream* default_instance_;
};
// -------------------------------------------------------------------

class PBVec2 : public ::google::protobuf::Message {
 public:
  PBVec2();
  virtual ~PBVec2();

  PBVec2(const PBVec2& from);

  inline PBVec2& operator=(const PBVec2& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PBVec2& default_instance();

  void Swap(PBVec2* other);

  // implements Message ----------------------------------------------

  PBVec2* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PBVec2& from);
  void MergeFrom(const PBVec2& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // @@protoc_insertion_point(class_scope:PBVec2)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  friend void  protobuf_AddDesc_GameStream_2eproto();
  friend void protobuf_AssignDesc_GameStream_2eproto();
  friend void protobuf_ShutdownFile_GameStream_2eproto();

  void InitAsDefaultInstance();
  static PBVec2* default_instance_;
};
// -------------------------------------------------------------------

class PBBall : public ::google::protobuf::Message {
 public:
  PBBall();
  virtual ~PBBall();

  PBBall(const PBBall& from);

  inline PBBall& operator=(const PBBall& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PBBall& default_instance();

  void Swap(PBBall* other);

  // implements Message ----------------------------------------------

  PBBall* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PBBall& from);
  void MergeFrom(const PBBall& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .PBVec2 position = 1;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 1;
  inline const ::PBVec2& position() const;
  inline ::PBVec2* mutable_position();
  inline ::PBVec2* release_position();
  inline void set_allocated_position(::PBVec2* position);

  // optional .PBVec2 velocity = 2;
  inline bool has_velocity() const;
  inline void clear_velocity();
  static const int kVelocityFieldNumber = 2;
  inline const ::PBVec2& velocity() const;
  inline ::PBVec2* mutable_velocity();
  inline ::PBVec2* release_velocity();
  inline void set_allocated_velocity(::PBVec2* velocity);

  // optional bool visible = 3;
  inline bool has_visible() const;
  inline void clear_visible();
  static const int kVisibleFieldNumber = 3;
  inline bool visible() const;
  inline void set_visible(bool value);

  // optional bool playerEnabled = 4;
  inline bool has_playerenabled() const;
  inline void clear_playerenabled();
  static const int kPlayerEnabledFieldNumber = 4;
  inline bool playerenabled() const;
  inline void set_playerenabled(bool value);

  // @@protoc_insertion_point(class_scope:PBBall)
 private:
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_velocity();
  inline void clear_has_velocity();
  inline void set_has_visible();
  inline void clear_has_visible();
  inline void set_has_playerenabled();
  inline void clear_has_playerenabled();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::PBVec2* position_;
  ::PBVec2* velocity_;
  bool visible_;
  bool playerenabled_;
  friend void  protobuf_AddDesc_GameStream_2eproto();
  friend void protobuf_AssignDesc_GameStream_2eproto();
  friend void protobuf_ShutdownFile_GameStream_2eproto();

  void InitAsDefaultInstance();
  static PBBall* default_instance_;
};
// -------------------------------------------------------------------

class PBPlayer : public ::google::protobuf::Message {
 public:
  PBPlayer();
  virtual ~PBPlayer();

  PBPlayer(const PBPlayer& from);

  inline PBPlayer& operator=(const PBPlayer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PBPlayer& default_instance();

  void Swap(PBPlayer* other);

  // implements Message ----------------------------------------------

  PBPlayer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PBPlayer& from);
  void MergeFrom(const PBPlayer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .PBVec2 position = 1;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 1;
  inline const ::PBVec2& position() const;
  inline ::PBVec2* mutable_position();
  inline ::PBVec2* release_position();
  inline void set_allocated_position(::PBVec2* position);

  // optional .PBVec2 velocity = 2;
  inline bool has_velocity() const;
  inline void clear_velocity();
  static const int kVelocityFieldNumber = 2;
  inline const ::PBVec2& velocity() const;
  inline ::PBVec2* mutable_velocity();
  inline ::PBVec2* release_velocity();
  inline void set_allocated_velocity(::PBVec2* velocity);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .PBTeam team = 4;
  inline bool has_team() const;
  inline void clear_team();
  static const int kTeamFieldNumber = 4;
  inline ::PBTeam team() const;
  inline void set_team(::PBTeam value);

  // optional bool connected = 5;
  inline bool has_connected() const;
  inline void clear_connected();
  static const int kConnectedFieldNumber = 5;
  inline bool connected() const;
  inline void set_connected(bool value);

  // @@protoc_insertion_point(class_scope:PBPlayer)
 private:
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_velocity();
  inline void clear_has_velocity();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_team();
  inline void clear_has_team();
  inline void set_has_connected();
  inline void clear_has_connected();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::PBVec2* position_;
  ::PBVec2* velocity_;
  ::std::string* name_;
  int team_;
  bool connected_;
  friend void  protobuf_AddDesc_GameStream_2eproto();
  friend void protobuf_AssignDesc_GameStream_2eproto();
  friend void protobuf_ShutdownFile_GameStream_2eproto();

  void InitAsDefaultInstance();
  static PBPlayer* default_instance_;
};
// ===================================================================


// ===================================================================

// PBGameStream

// optional bool active = 1;
inline bool PBGameStream::has_active() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PBGameStream::set_has_active() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PBGameStream::clear_has_active() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PBGameStream::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool PBGameStream::active() const {
  // @@protoc_insertion_point(field_get:PBGameStream.active)
  return active_;
}
inline void PBGameStream::set_active(bool value) {
  set_has_active();
  active_ = value;
  // @@protoc_insertion_point(field_set:PBGameStream.active)
}

// optional double pitchRatio = 2;
inline bool PBGameStream::has_pitchratio() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PBGameStream::set_has_pitchratio() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PBGameStream::clear_has_pitchratio() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PBGameStream::clear_pitchratio() {
  pitchratio_ = 0;
  clear_has_pitchratio();
}
inline double PBGameStream::pitchratio() const {
  // @@protoc_insertion_point(field_get:PBGameStream.pitchRatio)
  return pitchratio_;
}
inline void PBGameStream::set_pitchratio(double value) {
  set_has_pitchratio();
  pitchratio_ = value;
  // @@protoc_insertion_point(field_set:PBGameStream.pitchRatio)
}

// optional .PBBall ball = 3;
inline bool PBGameStream::has_ball() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PBGameStream::set_has_ball() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PBGameStream::clear_has_ball() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PBGameStream::clear_ball() {
  if (ball_ != NULL) ball_->::PBBall::Clear();
  clear_has_ball();
}
inline const ::PBBall& PBGameStream::ball() const {
  // @@protoc_insertion_point(field_get:PBGameStream.ball)
  return ball_ != NULL ? *ball_ : *default_instance_->ball_;
}
inline ::PBBall* PBGameStream::mutable_ball() {
  set_has_ball();
  if (ball_ == NULL) ball_ = new ::PBBall;
  // @@protoc_insertion_point(field_mutable:PBGameStream.ball)
  return ball_;
}
inline ::PBBall* PBGameStream::release_ball() {
  clear_has_ball();
  ::PBBall* temp = ball_;
  ball_ = NULL;
  return temp;
}
inline void PBGameStream::set_allocated_ball(::PBBall* ball) {
  delete ball_;
  ball_ = ball;
  if (ball) {
    set_has_ball();
  } else {
    clear_has_ball();
  }
  // @@protoc_insertion_point(field_set_allocated:PBGameStream.ball)
}

// repeated .PBPlayer player = 4;
inline int PBGameStream::player_size() const {
  return player_.size();
}
inline void PBGameStream::clear_player() {
  player_.Clear();
}
inline const ::PBPlayer& PBGameStream::player(int index) const {
  // @@protoc_insertion_point(field_get:PBGameStream.player)
  return player_.Get(index);
}
inline ::PBPlayer* PBGameStream::mutable_player(int index) {
  // @@protoc_insertion_point(field_mutable:PBGameStream.player)
  return player_.Mutable(index);
}
inline ::PBPlayer* PBGameStream::add_player() {
  // @@protoc_insertion_point(field_add:PBGameStream.player)
  return player_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PBPlayer >&
PBGameStream::player() const {
  // @@protoc_insertion_point(field_list:PBGameStream.player)
  return player_;
}
inline ::google::protobuf::RepeatedPtrField< ::PBPlayer >*
PBGameStream::mutable_player() {
  // @@protoc_insertion_point(field_mutable_list:PBGameStream.player)
  return &player_;
}

// -------------------------------------------------------------------

// PBVec2

// required float x = 1;
inline bool PBVec2::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PBVec2::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PBVec2::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PBVec2::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float PBVec2::x() const {
  // @@protoc_insertion_point(field_get:PBVec2.x)
  return x_;
}
inline void PBVec2::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:PBVec2.x)
}

// required float y = 2;
inline bool PBVec2::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PBVec2::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PBVec2::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PBVec2::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float PBVec2::y() const {
  // @@protoc_insertion_point(field_get:PBVec2.y)
  return y_;
}
inline void PBVec2::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:PBVec2.y)
}

// -------------------------------------------------------------------

// PBBall

// optional .PBVec2 position = 1;
inline bool PBBall::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PBBall::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PBBall::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PBBall::clear_position() {
  if (position_ != NULL) position_->::PBVec2::Clear();
  clear_has_position();
}
inline const ::PBVec2& PBBall::position() const {
  // @@protoc_insertion_point(field_get:PBBall.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::PBVec2* PBBall::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::PBVec2;
  // @@protoc_insertion_point(field_mutable:PBBall.position)
  return position_;
}
inline ::PBVec2* PBBall::release_position() {
  clear_has_position();
  ::PBVec2* temp = position_;
  position_ = NULL;
  return temp;
}
inline void PBBall::set_allocated_position(::PBVec2* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:PBBall.position)
}

// optional .PBVec2 velocity = 2;
inline bool PBBall::has_velocity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PBBall::set_has_velocity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PBBall::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PBBall::clear_velocity() {
  if (velocity_ != NULL) velocity_->::PBVec2::Clear();
  clear_has_velocity();
}
inline const ::PBVec2& PBBall::velocity() const {
  // @@protoc_insertion_point(field_get:PBBall.velocity)
  return velocity_ != NULL ? *velocity_ : *default_instance_->velocity_;
}
inline ::PBVec2* PBBall::mutable_velocity() {
  set_has_velocity();
  if (velocity_ == NULL) velocity_ = new ::PBVec2;
  // @@protoc_insertion_point(field_mutable:PBBall.velocity)
  return velocity_;
}
inline ::PBVec2* PBBall::release_velocity() {
  clear_has_velocity();
  ::PBVec2* temp = velocity_;
  velocity_ = NULL;
  return temp;
}
inline void PBBall::set_allocated_velocity(::PBVec2* velocity) {
  delete velocity_;
  velocity_ = velocity;
  if (velocity) {
    set_has_velocity();
  } else {
    clear_has_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:PBBall.velocity)
}

// optional bool visible = 3;
inline bool PBBall::has_visible() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PBBall::set_has_visible() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PBBall::clear_has_visible() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PBBall::clear_visible() {
  visible_ = false;
  clear_has_visible();
}
inline bool PBBall::visible() const {
  // @@protoc_insertion_point(field_get:PBBall.visible)
  return visible_;
}
inline void PBBall::set_visible(bool value) {
  set_has_visible();
  visible_ = value;
  // @@protoc_insertion_point(field_set:PBBall.visible)
}

// optional bool playerEnabled = 4;
inline bool PBBall::has_playerenabled() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PBBall::set_has_playerenabled() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PBBall::clear_has_playerenabled() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PBBall::clear_playerenabled() {
  playerenabled_ = false;
  clear_has_playerenabled();
}
inline bool PBBall::playerenabled() const {
  // @@protoc_insertion_point(field_get:PBBall.playerEnabled)
  return playerenabled_;
}
inline void PBBall::set_playerenabled(bool value) {
  set_has_playerenabled();
  playerenabled_ = value;
  // @@protoc_insertion_point(field_set:PBBall.playerEnabled)
}

// -------------------------------------------------------------------

// PBPlayer

// optional .PBVec2 position = 1;
inline bool PBPlayer::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PBPlayer::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PBPlayer::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PBPlayer::clear_position() {
  if (position_ != NULL) position_->::PBVec2::Clear();
  clear_has_position();
}
inline const ::PBVec2& PBPlayer::position() const {
  // @@protoc_insertion_point(field_get:PBPlayer.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::PBVec2* PBPlayer::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::PBVec2;
  // @@protoc_insertion_point(field_mutable:PBPlayer.position)
  return position_;
}
inline ::PBVec2* PBPlayer::release_position() {
  clear_has_position();
  ::PBVec2* temp = position_;
  position_ = NULL;
  return temp;
}
inline void PBPlayer::set_allocated_position(::PBVec2* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:PBPlayer.position)
}

// optional .PBVec2 velocity = 2;
inline bool PBPlayer::has_velocity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PBPlayer::set_has_velocity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PBPlayer::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PBPlayer::clear_velocity() {
  if (velocity_ != NULL) velocity_->::PBVec2::Clear();
  clear_has_velocity();
}
inline const ::PBVec2& PBPlayer::velocity() const {
  // @@protoc_insertion_point(field_get:PBPlayer.velocity)
  return velocity_ != NULL ? *velocity_ : *default_instance_->velocity_;
}
inline ::PBVec2* PBPlayer::mutable_velocity() {
  set_has_velocity();
  if (velocity_ == NULL) velocity_ = new ::PBVec2;
  // @@protoc_insertion_point(field_mutable:PBPlayer.velocity)
  return velocity_;
}
inline ::PBVec2* PBPlayer::release_velocity() {
  clear_has_velocity();
  ::PBVec2* temp = velocity_;
  velocity_ = NULL;
  return temp;
}
inline void PBPlayer::set_allocated_velocity(::PBVec2* velocity) {
  delete velocity_;
  velocity_ = velocity;
  if (velocity) {
    set_has_velocity();
  } else {
    clear_has_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:PBPlayer.velocity)
}

// optional string name = 3;
inline bool PBPlayer::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PBPlayer::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PBPlayer::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PBPlayer::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PBPlayer::name() const {
  // @@protoc_insertion_point(field_get:PBPlayer.name)
  return *name_;
}
inline void PBPlayer::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:PBPlayer.name)
}
inline void PBPlayer::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:PBPlayer.name)
}
inline void PBPlayer::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:PBPlayer.name)
}
inline ::std::string* PBPlayer::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:PBPlayer.name)
  return name_;
}
inline ::std::string* PBPlayer::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PBPlayer::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:PBPlayer.name)
}

// optional .PBTeam team = 4;
inline bool PBPlayer::has_team() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PBPlayer::set_has_team() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PBPlayer::clear_has_team() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PBPlayer::clear_team() {
  team_ = 0;
  clear_has_team();
}
inline ::PBTeam PBPlayer::team() const {
  // @@protoc_insertion_point(field_get:PBPlayer.team)
  return static_cast< ::PBTeam >(team_);
}
inline void PBPlayer::set_team(::PBTeam value) {
  assert(::PBTeam_IsValid(value));
  set_has_team();
  team_ = value;
  // @@protoc_insertion_point(field_set:PBPlayer.team)
}

// optional bool connected = 5;
inline bool PBPlayer::has_connected() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PBPlayer::set_has_connected() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PBPlayer::clear_has_connected() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PBPlayer::clear_connected() {
  connected_ = false;
  clear_has_connected();
}
inline bool PBPlayer::connected() const {
  // @@protoc_insertion_point(field_get:PBPlayer.connected)
  return connected_;
}
inline void PBPlayer::set_connected(bool value) {
  set_has_connected();
  connected_ = value;
  // @@protoc_insertion_point(field_set:PBPlayer.connected)
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::PBTeam> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PBTeam>() {
  return ::PBTeam_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_GameStream_2eproto__INCLUDED
